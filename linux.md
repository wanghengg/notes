# 0号进程、1号进程、2号进程

* idle进程由系统自动创建，运行在内核态，pid=0，是唯一一个没有通过调用`fork()`或者`kernel_thread()`产生的进程，其`task_init`是静态的，已经设定好
* init进程由idle通过调用`kernel_thread`创建，在内核空间完成初始化之后，加载`/sbin/init`程序创建了init进程，其pid=1，**<font color=red>init进程是所有用户进程的祖先</font>**，在系统启动完成后，init进程将变为守护进程监视系统其它用户进程。**系统由idle进程所处的内核态跳转到创建init 的用户态是通过系统调用实现的**
* **2号进程(kthreadd)是所有内核进程的祖先**

# linux开机启动流程

linux操作系统的启动过程一般分为四个阶段：

* BIOS启动引导阶段
* GRUB启动引导阶段
* 内核阶段
* init初始化阶段

## 启动第一步：加载BIOS

系统开机上电后，主板BIOS运行POST代码，监测系统外围一些设备（上电自检）。

## 启动第二步：读取MBR

接下来跳转到BIOS指定的硬盘的主引导记录（MBR，硬盘上第0磁道第一个扇区被称为MBR，大小为512字节，其中可用440字节），将主引导记录的内容复制到0X7C00地址所在的物理内存（此时系统处于实模式，直接访问物理地址）。**实际上复制到物理内存中的内容就是BootLoader，具体到linux是grub**

## 启动第三部：BootLoader

**BootLoader就是在操作系统内核运行之前运行的一段小程序**

BootLoader可以初始化硬件设备，建立内存空间映射图，将系统的软硬件环境带到一个合适状态，方便为最终调用操作系统内核准备好环境。

## 启动第四步： 加载内核

根据grub设定的内核映像所在地址，系统读取内核映像，并进行解压操作。操作完成后，linux的内核已经建立起来了。

## 用户层init运行inittab文件设定运行等级

内核被加载后，运行的第一个程序就是`/sbin/init`，创建1号进行，此进程是所有用户进程的祖先。然后在创建2号进程，是所有内核进程的祖先。

# 系统调用

 ![img](https://static001.geekbang.org/resource/image/86/a5/868db3f559ad08659ddc74db07a9a0a5.jpg)

## 用户态

* 将请求参数保存到寄存器
* 将系统调用名称转为系统调用号保存到寄存器`rax`中
* 通过`syscall`进入内核态

## 内核态

* 将用户态的寄存器保存到内核栈中
* 在系统调用表`sys_call_table`中根据系统调用号查找对应的函数
* 执行函数实现系统调用
* 函数执行完后恢复保存的用户态寄存器，用`sysretq`返回用户态，并返回系统调用返回值

# 编译

`.c`源文件编译成的可重定位目标文件`.o`的格式为

 ![img](https://static001.geekbang.org/resource/image/e9/d6/e9c2b4c67f8784a8eec7392628ce6cd6.jpg)

* .text：放编译好的二进制可执行代码
* .data：已经初始化好的全局变量
* .rodata：只读数据，例如字符串常量、const 的变量
* .bss：未初始化全局变量，运行时会置 0
* .symtab：符号表，记录的则是函数和变量
* .strtab：字符串表、字符串常量和变量名

为什么这里只有全局变量呢？**<font color=red>因为局部变量是放在栈里面的，是在程序运行过程中随时分配空间，随时释放的，所以没有保存在目标文件中。</font>**

可执行文件格式：

 ![img](https://static001.geekbang.org/resource/image/1d/60/1d8de36a58a98a53352b40efa81e9660.jpg) 

# 静态链接库和动态链接库

## 静态链接库

用`ar`指令将`.o`文件归档为静态链接库，静态链接库在编译获得可执行文件时将代码段复制进去，接下来程序运行的时候就不依赖这个静态链接库了。但是这样优缺点：1）如果这个静态链接库被多个程序使用，那么内存里面就有多份，浪费内存；2）一旦这个静态链接库更新，必须重新编译使用此库的程序，才能得到更新

## 动态链接库

动态链接库不仅仅是一组对象文件的简单归档，而是对多个文件重新组合，**可被多个程序共享**。

**<font color=red>当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</font>**

exec 比较特殊，它是一组函数：



* 包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；
* 不包含 p 的函数需要输入程序的全路径；
* 包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；
* 包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；
* 包含 e 的函数（execve, execle）以数组的形式接收环境变量。