# 什么是HTTP

HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

 ![img](https://gitee.com/wanghengg/picture/raw/master/2021/2781919e73f5d258ff1dc371af632acc.png)

* 互联网上绝大部分资源都使用 HTTP 协议传输；
* 浏览器是 HTTP 协议里的请求方，即 User Agent；
* 服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；
* CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；
* 爬虫是另一类 User Agent，是自动访问网络资源的程序。 

# 常见的HTTP状态码

![image-20210305115959041](https://gitee.com/wanghengg/picture/raw/master/2021/image-20210305115959041.png)

**1XX类状态码告知请求的处理进度和情况**

**2XX类状态码表示服务器成功处理了客户端的请求，是我们最愿意看到的状态**

* **[200 OK]**是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的响应头都会有body数据。

* **[204 No Content]**也是常见的成功状态码，也200 OK基本相同，但是响应报文没有body数据。

* **[206 Partial Content]**是应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的的全部，而是其中的一部分，也是服务器处理成功的状态。

**3XX类状态码表示客户端请求的资源发生了变动，需要客户端用新的URI重新发送请求获取资源，也就是重定向，需要进一步操作**

* ****

  **[301 Move Permanently]**表示永久重定向，说明请求的资源已经不存在了，需要改用新的URI再次访问。

* **[302 Found]**表示资源的URI已经临时定位到其他位置了，说明请求的资源还在，但是暂时需要用另一个URI访问。

* **[304 Not Modified]**不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

**4XX类状态码表示客户端发送的报文有误，服务器无法处理**

* **[400 Bad Request]**表示客户端请求的报文有错误，但只是一个笼统的错误。
* **[403 Forbidden]**表示服务器禁止访问资源，并不是客户端的请求出错。
* **[404 Not Found]**表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

**5XX类状态码表示客户端请求报文正确，但是<font color=red>服务器处理时内部出现了错误</font>，属于服务器端的错误**

**[500 Internal Server Error]**与400类似，是个笼统的错误码，服务器发生了什么错误我们并不知道。

**[501 Not Implemented]**表示客户端请求的功能还不支持。

**[502 Bad Gateway]**通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器的时候发生了错误。

**[503 Service Unavailable]**表示服务器当前很忙， 暂时无法响应。

# HTTP的特点（优缺点）

HTTP协议有优缺点一体的双刃剑，分别是**无状态、明文传输**，同时还有一大缺点**不安全**

**<font color=red>对于无状态的解决方法之一就是使用Cookie技术。</font>**客户端第一次向服务器发送请求报文时，服务器在报文中添加Cookie返回，以后客户端每次发送请求报文时都带上Cookie，服务器接收到报文后通过里面的Cookie信息就可以知道客户端的身份。

# HTTP和HTTPS的区别

1. HTTP传输的是明文信息，存在安全风险。HTTP解决了HTTP传输不安全的缺陷，在TCP和HTTP之间加入了SSL/TLS协议，使报文能加密传输。
2. HTTP建立连接相对简单，通过TCP三次握手之后就可以进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才能进行加密传输。
3. HTTP的端口号是80，HTTPS的端口号是443
4. HTTPS协议需要向CA（证书权威机构）申请数字证书，用来保证服务器的身份是可信的。

**<font color=red>用于HTTP信息明文传输，所以存在窃听风险、篡改风险、冒充风险</font>**

## HTTPS如何解决上面的三个风险的？

* **混合加密（对称加密和非对称加密混合）**的方式实现了报文信息的机密性，解决了窃听风险。
* **摘要算法**的方式来保证信息的**完整性**，解决了信息的篡改风险。
* 将服务器的公钥放到数字证书中，解决了服务器冒充的风险。

## 对称加密和非对称加密

HTTPS采用的是**对称加密**和**非对称加密**结合的混合加密方式

* 在通信建立之前采用非对称加密的方式交换会话密钥，后续就不需要再使用非对称加密。
* 在通信过程中全部使用的是对称加密的会话密钥的方式加密明文数据。

### 采用混合加密的原因

* 对称加密只有一个密钥：运算速度快，但是密钥必须保密，无法做到安全的密钥交换。
* 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但是速度慢。
* 为了保证密钥安全交换同时保证报文交换速度，采用了混合加密方式。

## 数字证书

![image-20210305120123220](https://gitee.com/wanghengg/picture/raw/master/2021/image-20210305120123220.png)

客户端向服务端索要公钥，然后用公钥加密信息，但是怎么保证公钥不被篡改？

* 这里用到了数字证书，服务器首先向第三方权威机构CA（数字证书认证机构）申请证书，CA用自己的私钥将服务器的公钥数字签名并颁发数字证书，然后将服务器公钥和证书一起发送给客户端，客户端本地已经实现安装了CA的公钥，所以客户端收到服务器发来的公钥和证书后用CA的公钥确认服务器数字证书的真实性，如果证书有效，那么公钥也可信，接下来客户端课服务器之间就可以通过公钥进行对称加密传输信息了。

# HTTP/1.1、HTPP/2、HTTP/3演变

## HTTP/1.1特点

* TCP采用长连接的方式改善了HTTP/1.0短连接造成的开销。
* 支持管道网络传输，只要一个请求发出去了，不必等其回来，就可以发出第二个请求，减少整体响应时间。

## HTTP/1.1的缺点

* 请求/响应头部未经压缩就发送，首部信息越多延迟越大，导致只能压缩body数据。
* 发送冗长的首部。每次发送相同的首部造成资源浪费。
* 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，造成队头阻塞。
* 没有请求优先级控制。
* 请求只能从客户端开始，服务器只能被动响应。

## HTTP/2的改进

1. **头部压缩。**如果同时发送多个请求它们的头部是一样的，那么协议会消除重复的部分。这就是HPACK算法。
2. **二进制格式。**HTTP/2不像HTTP/1.1一样使用纯文本形式的报文，而是全面使用了二进制格式。对于计算机来说，接收到报文后不需要将明文格式的报文转换为二进制，提高了数据传输的效率。
3. **数据流。**HTTP/2的数据包不是按顺序发送的，同一个连接里连续的数据包可能属于不同的响应。每个请求或者响应的数据包，成为一个数据流。客户端还可以指定数据流的优先级。优先级高的请求，服务器优先响应。
4. **多路复用。**HTTP/2可以在一个TCP连接里面并发多个请求或者响应，而不用按照顺序一一对应。不需要排队等待，也就没有队头阻塞的问题了。*<font color=red>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分</font>*
5. **服务器推送。**服务器不再是被动地响应，也可以主动向客户端发送消息。

![image-20210305120201826](https://gitee.com/wanghengg/picture/raw/master/2021/image-20210305120201826.png)

### HTTP/2的缺陷

HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

# TCP三次握手的目的是什么？为什么不用两次和四次？

可以从三方面分析三次握手的原因：

* **<font color=red>三次握手才可以阻止历史重复连接的初始化</font>**
* **<font color=red>三次握手才能同步双方的初始序列号</font>**
* **<font color=red>三次握手才能避免资源浪费</font>**

## 原因一：避免历史连接



![image-20210304010703384](https://gitee.com/wanghengg/picture/raw/master/2020/image-20210304010703384.png)

客户端发送请求连接报文，但是由于网络拥塞一直没有收到确认报文，所以客户端重新发送新的SYN请求连接报文，但是恰好旧的请求连接报文在新的请求连接报文到达之前到达了服务端，那么此时服务端就会返回一个SYN+ACK报文给客户端并且完成连接，那么就造成了历史连接初始化了连接，新的连接请求接收到之后无法建立新的连接。三次握手的情况下，在第三次客户端发送确认报文之前，根据上下文判断这是一个历史连接（序列号过期或超时），那么客户端就会发送RST报文给服务端，终止这个连接。

## 原因二：同步双方初始序列号

TCP协议的通信双方，都必须维护一个序列号，序列号是可靠传输的关键因素，它的作用：

* 接收方可以去除重复的数据
* 接受可以根据数据包的序列号对接受到的包排序，使接受的数据不会乱序
* 可以标识发出去的数据包中，哪些是已经被对方接手的

当客户端发送携带**初始序列号**的SYN报文时，服务端返回一个ACK应答报文，表示客户端的SYN报文已经被服务端成功接收，那当服务端发送**初始序列号**给客户端时，也需要得到客户端的应答响应，表示已经接收到服务端发送的初始序列号。这样一来一回，才能确保双方的初始化序列号都能被同步。

## 原因三：避免资源浪费

如果只有两次握手，假设当客户端发送第一次请求连接由于网络拥塞的原因，迟迟未到达服务器，客户端没有接收到确认报文，认为服务端没有接收到，触发超时重传，于是重新发送新的请求报文并与服务器建立连接，等这次连接断开了，之前滞留的那个请求报文又重新到达了服务端，让服务端认为是新的连接请求，就会发确认报文到接收端并且建立连接，但是客户端此时已经关闭，即时没有关闭此时也不是处于SYS-SENT状态，也不会响应服务端的确认信息，服务端就这样在等待中浪费了资源。如果客户端的SYN阻塞，重复多次发送SYN报文，那么服务器在接收到请求后就会建立起多个冗余的连接。

但是有第三次报文确定就不一样了，第三次，客户端发送ACK确认报文到服务端，服务端接受到后就知道客户端已经收到自己的确认消息了，如果再次发生刚才的问题，服务端再次接收到了滞留在网络中的请求连接报文，发送确认报文给客户端，当客户端一直没有发送响应报文回来时，服务端也就会知道这是错误消息，就不会一直等待了，也就没有资源的浪费了。

## 不使用四次握手的原因

三次握手理论上就已经可以建立可靠连接，不需要使用更多的通信次数。实际上第二次握手中客户端发送ACK+SYN包可以看做ACK包和SYN合并一起发送。

# 为什么挥手需要四次？三次不行吗？

# 网址访问过程详解

浏览器在拿到 url 时，首先会对 url 进行解析，将域名与实际的文件路径分离，然后需要使用 DNS 协议，通过域名得到 IP 地址。
浏览器会查询浏览器缓存，如果有这个网址的缓存就可以直接获取到 IP，如果没有就进一步访问本机缓存，如果本机缓存也没有才会发起 DNS 请求。
而 DNS 的服务器是一个树状结构，对于域名来说是倒着进行解析的，根节点是根 DNS 服务器，他的子节点为 com、cn 这种顶级域 dns 服务器，然后进一步向下进行解析。
以 baidu.com 为例，当我们的电脑需要发起 DNS 请求的时候，会先对根 DNS 服务器发起请求，这个服务器的 IP 地址一般在每台电脑上都有，我们一般会设置为 8.8.8.8 或者 114.114.114.114，我们的电脑在访问根 DNS 服务器后，会得到 con 域 DNS 服务器的 IP，然后会继续访问 con 域 DNS 服务器，这时就能得到 baicu.com 的 IP 地址了。

得到 ip 后浏览器会先与服务器通过 TCP 三次握手建立连接，然后构建 HTTP 请求。
在解析 url 时，我们能获取到需要请求资源的资源路径、端口号、请求参数等信息，这些信息会被存储在 http 头中，通过 DNS 请求获取到 ip 后，浏览器会构建并发送 HTTP 请求或者 HTTPS 请求，HTTPS 就是在 HTTP 的基础上加了一个 TLS 协议来进行数据加密，这个我们待会说。
HTTP 请求有很多种，但对资源的操作离不开增删改查，也就对应着 POST、DELETE、PUT、GET 请求。最常用的是 GET 和 POST，其区别在于 GET 的参数是在 url 中的，而 POST 的参数是在请求的 body 中。
以 GET 为例，当需要发送 HTTP 请求的时候，同样也不是直接就发送了，需要先查询浏览器缓存。浏览器中的缓存分为强缓存和协商缓存，浏览器发起 HTTP 请求时首先会根据 http 头信息来判断是存有强缓存，以及其是否过期，如果有强缓存且未过期则命中，不会发送请求到服务器了。如果强缓存没命中，则会向服务器发起请求，这个请求的 Header 头中会带有浏览器最后一次请求该资源的时间和一个资源校验码(使用资源修改时间、资源大小等信息生成)，服务器收到这个请求后会判断协商缓存是否过期，如果过期则返回新的资源信息，如果没过期则返回 304 状态码，表示资源未更新，可以使用缓存中的资源。

HTTP 请求发出后会将数据包交给下层协议栈处理，在传输层和网络层该数据包会被分别加上 TCP 头和 IP 头，并且被发送出去，沿路的网关会收到这个数据包并进行识别和转发，直到该数据包被服务器收到，通过相同的流程返回回复数据包。

一般来说，浏览器第一次从服务器请求的资源都是一个 HTML 文件，例如服务端默认的 index.html 等，浏览器获取到这个 HTML 文件就会对其进行解析，构建出一棵DOM树，并通过执行其中的 js 代码发起更多的请求，请求渲染页面需要的其他资源，CSS 或者一些外链的图片等，拿到 CSS 后将其与 DOM 树结合进行更进一步的渲染，我们就能看到页面了。

最后再补充一下 HTTPS，由于 HTTP 是使用信息明文传播，所以会有窃听、篡改、冒充等风险，所以 HTTPS 在 HTTP 的基础上加上了 SSL 层，通过加密的方式来保证数据安全。
SSL 通过加密防止窃听，通过签名来防止篡改，通过证书来防止冒充。
HTTPS 协议在客户端与服务端开始通信前，会进行密钥协商，通过一轮非对称加密，一般是RSA加密来传递后序通信过程使用的对称密钥，由于非对称加密较慢，后续通信过程中使用对称加密。在密钥协商的过程中，服务端会将自己的证书发送给客户端，客户端会到 CA 机构通过摘要值验证证书的合法性，从而防止中间人攻击。

<font color=red>补充网络层通过路由表根据目的ip地址确定IP数据包的下一跳，网络层的下一层是数据链路层，所以还需要知道下一跳的MAC地址，由于主机的路由表可以找到下一跳的IP地址，所以可以通过ARP协议获取下一跳的MAC地址。主机首先查看是否本地缓存有下一跳的MAC地址，有的话直接使用，没有的就通过广播发送ARP请求，这个请求包里面包含了想要知道的MAC地址的主机IP地址，当同一个网段中的所有设备收到这个包时将里面的IP地址与自己的IP地址比较，匹配的话就将自己的MAC地址放入包中返回给主机，不匹配则直接丢掉这个包，因此主机可以得到下一跳的MAC地址。</font>

最后再补充一下 HTTPS，由于 HTTP 是使用信息明文传播，所以会有窃听、篡改、冒充等风险，所以 HTTPS 在 HTTP 的基础上加上了 SSL 层，通过加密的方式来保证数据安全。
SSL 通过加密防止窃听，通过签名来防止篡改，通过证书来防止冒充。
HTTPS 协议在客户端与服务端开始通信前，会进行密钥协商，通过一轮非对称加密，一般是RSA加密来传递后序通信过程使用的对称密钥，由于非对称加密较慢，后续通信过程中使用对称加密。在密钥协商的过程中，服务端会将自己的证书发送给客户端，客户端会到 CA 机构通过摘要值验证证书的合法性，从而防止中间人攻击。